!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.TortoiseDB=t():e.TortoiseDB=t()}(global,function(){return function(e){var t={};function o(s){if(t[s])return t[s].exports;var n=t[s]={i:s,l:!1,exports:{}};return e[s].call(n.exports,n,n.exports,o),n.l=!0,n.exports}return o.m=e,o.c=t,o.d=function(e,t,s){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(o.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)o.d(s,n,function(t){return e[t]}.bind(null,n));return s},o.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="",o(o.s=2)}([function(e,t){e.exports=require("express")},function(e,t){e.exports=require("debug")},function(e,t,o){const s=o(3),n=o(5),r=o(6),i=o(7);e.exports=class{constructor({name:e="default",port:t=process.env.PORT,mongoURI:o=process.env.MONGODB_URI,batchLimit:n=1e3}={}){this.port=t,this.mongoShell=new s(e,o),this.server=i(this),this.syncInProgress=!1,this.batchLimit=n}start(){this.server.listen(this.port),console.log(`TurtleDB server ready to go on port ${this.port}!`)}startSyncSession(){const e=e=>{this.syncInProgress?console.log("Sorry another sync still in progress."):(clearInterval(this.intervalObj),this.syncInProgress=!0,this.syncFrom(),e())};return new Promise((t,o)=>{this.syncInProgress?(console.log("Sorry another sync still in progress."),this.intervalObj=setInterval(e.bind(this,t),200)):(this.syncInProgress=!0,this.syncFrom(),t())})}syncFrom(){this.syncFromSession=new r(this.mongoShell)}syncTo(){this.syncToSession=new n(this.mongoShell,this.batchLimit)}dropDB(){return this.mongoShell.dropDB()}}},function(e,t,o){const{MongoClient:s,ObjectId:n}=o(4);e.exports=class{constructor(e,t){let o;this._store="store",this._meta="metaStore",this._syncFromStore="syncFromStore",this._syncToStore="syncToStore",this._url=t,this._dbName=`tortoiseDB-${e}`,this.connect().then(e=>(o=e).listCollections().toArray()).then(e=>{const t=e.map(e=>e.name);t.includes(this._store)||o.createCollection(this._store).then(()=>o.collection(this._store).createIndex({_id_rev:1})),t.includes(this._meta)||o.createCollection(this._meta),t.includes(this._syncFromStore)||o.createCollection(this._syncFromStore),t.includes(this.syncToStore)||o.createCollection(this._syncToStore)}).catch(e=>console.log("Error:",e))}connect(){return s.connect(this._url,{useNewUrlParser:!0}).then(e=>(this._client=e,this._client.db(this._dbName))).catch(e=>console.log("error:",e))}command(e,t,o,s){return this.connect().then(t=>t.collection(e)).then(e=>"CREATE"===t?e.insertOne(o):"CREATE_MANY"===t?e.insertMany(o):"READ"===t?e.find(o,s).toArray():"READ_ALL"===t?e.find({}).toArray():"READ_BETWEEN"===t?e.find({_id:{$gt:n(o.min),$lte:n(o.max)}}).toArray():"READ_UP_TO"===t?e.find({_id:{$lte:n(o.max)}}).toArray():"GET_MAX_ID"===t?e.find().sort({_id:-1}).limit(1).toArray():"GET_ALL_IDS"===t?e.find({},{_id:1}).sort({_id:1}).map(function(e){return e._id}).toArray():"GET_ALL_IDS_GREATER_THAN"===t?e.find({_id:{$gt:n(o.min)}},{_id:1}).sort({_id:1}).map(function(e){return e._id}).toArray():"UPDATE"===t?e.update({_id:o._id},o,{upsert:!0}):void 0).then(e=>(this._client.close(),e)).catch(e=>{this._client.close(),console.log(`${t} error:`,e)})}updateManyMetaDocs(e){let t=Promise.resolve();return e.forEach(e=>{t=t.then(()=>this.command(this._meta,"UPDATE",e))}),t}getStoreDocsByIdRevs(e){return this.command(this._store,"READ",{_id_rev:{$in:e}})}getMetaDocsByIds(e){return this.command(this._meta,"READ",{_id:{$in:e}})}updateMetaDocs(e){return this.command(this._meta,"UPDATE_MANY",e)}dropDB(){return this.connect().then(e=>e.dropDatabase()).then(e=>this._client.close()).catch(e=>console.log("DropDB Error",e))}}},function(e,t){e.exports=require("mongodb")},function(e,t){e.exports=class{constructor(e,t){this.sessionID=(new Date).toISOString(),this.mongoShell=e,this.batchLimit=t}getChangedMetaDocsForTurtle(e){const t=e.body.lastTurtleKey;return this.turtleID=e.body.turtleID,this.getHighestTortoiseKey().then(()=>t===this.highestTortoiseKey?{lastBatch:!0,metaDocs:[]}:this.getMetaDocsBetweenStoreKeys(t,this.highestTortoiseKey).then(e=>this.getUniqueIDs(e)).then(e=>this.getMetaDocsByIDs(e)).then(()=>this.sendBatchChangedMetaDocsToTurtle()))}getHighestTortoiseKey(){return this.mongoShell.command(this.mongoShell._store,"GET_MAX_ID",{}).then(e=>{0===e.length?this.highestTortoiseKey="0":this.highestTortoiseKey=e[0]._id.toString()})}getMetaDocsBetweenStoreKeys(e,t){return"0"!==e?this.mongoShell.command(this.mongoShell._store,"READ_BETWEEN",{min:e,max:t}):this.mongoShell.command(this.mongoShell._store,"READ_UP_TO",{max:t})}getUniqueIDs(e){let t={};for(let o=0;o<e.length;o++){const s=e[o]._id_rev.split("::")[0];t[s]||(t[s]=!0)}return Object.keys(t)}getMetaDocsByIDs(e){return this.mongoShell.command(this.mongoShell._meta,"READ",{_id:{$in:e}}).then(e=>this.changedTortoiseMetaDocs=e)}sendBatchChangedMetaDocsToTurtle(){return{metaDocs:this.changedTortoiseMetaDocs.splice(0,this.batchLimit),lastBatch:0===this.changedTortoiseMetaDocs.length}}getTortoiseDocsForTurtle(e){const t=e.body.revIds;return this.getStoreDocsForTurtle(t).then(()=>this.createNewSyncToTurtleDoc()).then(()=>this.sendBatchDocsToTurtle())}getStoreDocsForTurtle(e){return this.mongoShell.command(this.mongoShell._store,"READ",{_id_rev:{$in:e}},{fields:{_id:0}}).then(e=>this.storeDocsForTurtle=e)}sendBatchDocsToTurtle(){let e=this.storeDocsForTurtle.splice(0,this.batchLimit),t=0===this.storeDocsForTurtle.length;const o={docs:e,lastBatch:t};return t&&(o.newSyncToTurtleDoc=this.newSyncToTurtleDoc),o}updateSyncToTurtleDoc(){return this.mongoShell.command(this.mongoShell._syncToStore,"UPDATE",this.newSyncToTurtleDoc)}createNewSyncToTurtleDoc(){return this.getSyncToTurtleDoc().then(e=>{let t={lastKey:this.highestTortoiseKey,sessionID:this.sessionID};this.newSyncToTurtleDoc=Object.assign(e,{history:[t].concat(e.history)})})}getSyncToTurtleDoc(){return this.mongoShell.command(this.mongoShell._syncToStore,"READ",{_id:this.turtleID}).then(e=>0===e.length?this.initializeSyncToTurtleDoc(this.turtleID):e[0])}initializeSyncToTurtleDoc(e){const t={_id:e,history:[]};return this.mongoShell.command(this.mongoShell._syncToStore,"CREATE",t).then(()=>t).catch(e=>console.log(e))}}},function(e,t){e.exports=class{constructor(e){this.docsFromTurtle=[],this.updatedMetaDocs=[],this.newTurtleMetaDocs=[],this.mongoShell=e}getLastTortoiseKey(e){const t=e._id,o=e.history[0];return this.mongoShell.command(this.mongoShell._syncFromStore,"READ",{_id:t}).then(e=>{const s=e[0];if(s){const e=s.history[0];return e?e.lastKey!==o.lastKey?0:e.lastKey:0}return this.createSyncFromDoc(t).then(()=>0)})}createSyncFromDoc(e){const t={_id:e,history:[]};return this.mongoShell.command(this.mongoShell._syncFromStore,"CREATE",t)}findAllMissingLeafNodes(e){return this.createMetaDocPairs(e).then(e=>this.createNewMetaDocs(e)).then(e=>this.findMissingLeafNodes(e)).then(e=>e)}createMetaDocPairs(e){let t={};const o=e.map(e=>e._id);return this.mongoShell.getMetaDocsByIds(o).then(o=>(e.forEach(e=>{t[e._id]={turtle:e,tortoise:null}}),o.forEach(e=>{t[e._id].tortoise=e}),t))}createNewMetaDocs(e){return this.newRevisionTrees(e),this.newMetaDocs(e),e}newRevisionTrees(e){Object.keys(e).forEach(t=>{let o=e[t],s=o.tortoise,n=o.turtle;if(s){const e=s._revisions,t=n._revisions;o.newRevisionTree=this.mergeRevTrees(e,t)}else o.new=null})}newMetaDocs(e){Object.keys(e).forEach(t=>{let o=e[t],s=o.tortoise;o.new=s?{_id:s._id,_revisions:o.newRevisionTree,_winningRev:this.getWinningRev(o.newRevisionTree),_leafRevs:this.collectActiveLeafRevs(o.newRevisionTree)}:null})}findMissingLeafNodes(e){console.log("metaDocTrios",e);let t=[],o=this.collectAllLeafIdRevs(e);return console.log("allLeafNodes",o),this.filterToMissingLeafNodes(o).then(o=>{t=o;let s=this.getNewTurtleLeafNodes(e);t=t.concat(s)}).then(()=>{this.sortMetaDocsForSave(e)}).then(()=>t)}collectAllLeafIdRevs(e){let t=[];return Object.keys(e).forEach(o=>{let s=e[o],n=(s.tortoise,s.new);if(n){const e=this.collectAllLeafRevs(n._revisions),o=n._id;e.forEach(e=>{let s=o+"::"+e;t.push(s)})}}),t}collectAllLeafRevs(e,t=[]){0===e[2].length&&t.push(e[0]);for(let o=0;o<e[2].length;o++)this.collectAllLeafRevs(e[2][o],t);return t}filterToMissingLeafNodes(e){return this.mongoShell.getStoreDocsByIdRevs(e).then(t=>{const o=t.map(e=>e._id_rev);return e.filter(e=>!o.includes(e))})}getNewTurtleLeafNodes(e){let t=[];return Object.keys(e).forEach(o=>{let s=e[o],n=s.new,r=s.turtle;if(!n&&r._winningRev)for(let e=0;e<r._leafRevs.length;e++)t.push(r._id+"::"+r._leafRevs[e])}),console.log("remainingTurtleLeafNodes",t),t}sortMetaDocsForSave(e){Object.keys(e).forEach(t=>{let o=e[t],s=o.new,n=o.turtle;s?this.updatedMetaDocs.push(s):this.newTurtleMetaDocs.push(n)})}insertUpdatedMetaDocs(){return Promise.resolve().then(()=>this.mongoShell.updateManyMetaDocs(this.updatedMetaDocs)).then(()=>{if(this.newTurtleMetaDocs.length>0)return this.mongoShell.command(this.mongoShell._meta,"CREATE_MANY",this.newTurtleMetaDocs)})}insertNewDocsIntoStore(){return 0===this.docsFromTurtle?(console.log("FYI: No docs were sent over from turtle to insert."),Promise.resolve()):this.docsFromTurtle.length>0?this.mongoShell.command(this.mongoShell._store,"CREATE_MANY",this.docsFromTurtle):void 0}updateSyncFromTurtleDoc(e){return this.mongoShell.command(this.mongoShell._syncFromStore,"UPDATE",e)}saveDocsBatch(e){return Promise.resolve(this.docsFromTurtle.push(...e))}mergeRevTrees(e,t){const o=e[2],s=t[2],n=this.findCommonNodes(o,s),r=this.getNode2ChildrenDiffs(o,s);e[2]=[...o,...r];for(let e=0;e<n.length;e++){let t=n[e];this.mergeRevTrees(t[0],t[1])}return e}findCommonNodes(e,t){let o=[];for(let s=0;s<e.length;s++){let n=e[s];for(let e=0;e<t.length;e++){let s=t[e];s[0]===n[0]&&o.push([n,s])}}return o}getNode2ChildrenDiffs(e,t){const o=e.map(e=>e[0]);return t.filter(e=>!o.includes(e[0]))}getWinningRev(e){return this.collectActiveLeafRevs(e).sort((e,t)=>{let[o,s]=e.split("-"),[n,r]=t.split("-");return(o=parseInt(o,10))>(n=parseInt(n,10))?-1:o<n?1:s>r?-1:1})[0]}collectActiveLeafRevs(e,t=[]){0!==e[2].length||e[1]._deleted||t.push(e[0]);for(let o=0;o<e[2].length;o++)this.collectActiveLeafRevs(e[2][o],t);return t}findMissingLeafNodesOfDoc(e){const t=this.collectAllLeafRevs(e._revisions),o=e._id,s=t.map(e=>o+"::"+e);return this.mongoShell.getStoreDocsByIdRevs(s).then(e=>{const t=e.map(e=>e._id_rev);return s.filter(e=>!t.includes(e))})}}},function(e,t,o){e.exports=function(e){const t=o(0),s=o(8),n=o(9)(e),r=o(10)(e),i=t();return i.use(s.json({limit:"50mb"})),i.use((e,t,o)=>{t.header("Access-Control-Allow-Origin","*"),t.header("Access-Control-Allow-Headers","Origin, X-Requested-With, Content-Type, Accept"),o()}),i.use("/",n),i.use("/",r),i.get("/connect",(e,t)=>{t.status(200).send()}),i.get("/dropdb",(t,o)=>{e.dropDB().then(()=>o.status(200).send())}),i}},function(e,t){e.exports=require("body-parser")},function(e,t,o){e.exports=function(e){var t=o(0).Router();const s=o(1);var n=s("tortoiseDB:syncTo"),r=s("tortoiseDB:syncToSummary");return t.post("/_changed_meta_docs",(t,o)=>{if(t.body.initial)e.syncTo(),r("\n\n ------- NEW Tortoise ==> Turtle SYNC ------"),n("\n #1 HTTP POST request <== Initial Turtle requesting any changes"),e.syncToSession.getChangedMetaDocsForTurtle(t).then(t=>{n(`\n #2 HTTP response ==> Turtle with (${t.metaDocs.length}) changed metadocs`),0===t.metaDocs.length&&(n("\n No sync needed - last key and highest key are equal"),r("\n ------- Tortoise ==> Turtle sync complete ------"),e.syncInProgress=!1),o.send(t)}).catch(e=>console.log(e));else{n("\n #1 HTTP POST request <== Turtle follow up request for next batch of metadocs");let t=e.syncToSession.sendBatchChangedMetaDocsToTurtle();o.send(t),n(`\n #2 HTTP response ==> Turtle with (${t.metaDocs.length}) changed metadocs`)}}),t.post("/_changed_docs",(t,o)=>{if(t.body.initial)n(`\n #3 HTTP POST request <== Initial Turtle requesting (${t.body.revIds.length}) store docs`),e.syncToSession.getTortoiseDocsForTurtle(t).then(e=>{n(`\n #4 HTTP response ==> Turtle with (${e.docs.length}) store docs`),o.send(e)});else{n("\n #3 HTTP POST request <== Turtle follow up request for store docs");let t=e.syncToSession.sendBatchDocsToTurtle();n(`\n #4 HTTP response ==> Turtle with (${t.docs.length}) store docs`),o.send(t)}}),t.get("/_confirm_sync",(t,o)=>{n("\n #5 HTTP GET request <== Turtle with confirmation"),e.syncToSession.updateSyncToTurtleDoc().then(()=>{n("\n #6 HTTP response ==> Turtle with updated sync history and confirmation"),o.status(200).send(),e.syncInProgress=!1,r("\n ------- Tortoise ==> Turtle sync complete ------")}).catch(e=>console.log(e))}),t}},function(e,t,o){e.exports=function(e){var t=o(0);const s=o(1);var n=t.Router(),r=s("tortoiseDB:syncFrom"),i=s("tortoiseDB:syncFromSummary");return n.post("/_last_tortoise_key",(t,o)=>{e.startSyncSession().then(()=>{i("\n\n ------- NEW Turtle ==> Tortoise SYNC ------"),r("\n #1 HTTP POST request <== Turtle requesting checkpoint from last sync session")}).then(()=>e.syncFromSession.getLastTortoiseKey(t.body)).then(e=>{r("\n #2 HTTP response ==> Turtle with last key"),o.send(e.toString())}).catch(e=>console.log("_last_tortoise_key error:",e))}),n.post("/_missing_rev_ids",(t,o)=>{r(`\n #3 HTTP POST request <== Turtle with (${t.body.metaDocs.length}) changed meta docs`),e.syncFromSession.findAllMissingLeafNodes(t.body.metaDocs).then(e=>{r(`\n #4 HTTP response ==> Turtle requesting (${e.length}) missing leaf-revs/docs`),o.send(e)}).catch(e=>console.log("_missing_rev_ids route error:",e))}),n.post("/_insert_docs",(t,o)=>{r(`\n #5 HTTP POST request <== Turtle with (${t.body.docs.length}) missing leaf-revs/docs`),t.body.lastBatch?e.syncFromSession.saveDocsBatch(t.body.docs).then(()=>e.syncFromSession.insertUpdatedMetaDocs()).then(()=>e.syncFromSession.insertNewDocsIntoStore()).then(()=>e.syncFromSession.updateSyncFromTurtleDoc(t.body.newSyncToTortoiseDoc)).then(()=>r("\n #6 HTTP response ==> Turtle with confirmation of insert and sync history")).then(()=>o.status(200).send()).then(()=>i("\n ------- Turtle ==> Tortoise sync complete ------ ")).catch(e=>console.log("_insert_docs error:",e)):e.syncFromSession.saveDocsBatch(t.body.docs).then(()=>{r("\n #6 HTTP response ==> Batch saved to Tortoise"),o.status(200).send()}).catch(e=>console.log("_insert_docs error:",e))}),n}}])});